
f209 属性11 台区识别启停标记

关键是怎么找出主分支关于台区识别的所有的处理？

到时可以通过376.2来找出处理？

1. 在《采集任务调度管理APP深化应用实现》中，台区识别包含非本台区的电能表信息上报和节点拒绝信息主动上报。

在《采集任务调度管理APP深化应用实现》中主要是描述APP间的操作，还是需要通过主分支来看看是怎么处理的？

06H-f5：这是上报给集中器的，需要找到现在的程序是在什么地方接收376.2协议的报文的，处理，通过通信协议来区分非本台区的电能表信息上报和节点拒绝信息主动上报。
（关键还是在于处理报上来的数据）

2. 是不是《hplc技术应用手册》中376.2相关的那些项都要处理？

集中的任务：
1. 响应主站发起的台区识别使能及禁止命令。-- 这个就是处理主站下发的报文。
2. 通过下发376.2报文来控制路由启动或结束台区识别功能。
3. 处理cco上报错误档案信息，（这个还不知道怎么弄）
4. 集中器把上报的台区识别名单进项存储。


其实要做的工作有：
1. 解析主站下发的启动停止台区识别的报文（这个是对上行接口的处理）
2. 通过376.2协议来控制路由处理台区识别的启动和停止。
3. 解析06H-f5的报文，将的到的数据存储到数据中心。
	其中，1和2应该是比较好处理的，3的工作量最大，而且牵扯到台区识别的具体处理。
	
最大的问题是，我对主分支的代码理解的不是很透彻，



第一步：就是做f209 11和22的上行接口，这也是比较好做的。

05H-f6---允许/ 禁止台区识别  0 禁止； 1 允许
f209- 11（台区识别启停标记）

05H-f200
f209-22  拒绝节点上报使能标志

设置使能的时候，要把使能路由这个要做好。

高级APP是如何通知采集任务调度的呢？
把参数存到数据中心，数据中心给出通知，任务调度再去读，通过这个参数来启动台区识别。


第二步： 



要理清主分支台区识别的流程：

1. f209 11 也就是 0停止 1启动
   376.2 05h-f6 也是 一位表示停止和启动

   主分支在处理的时候，是如果启动的时候，写了一个文件。但是文件中写了什么内容？
		- 存放台区识别的信息？  文件创建的时间、记录条数和电表bit
		可能也不是这些东西，具体是啥呢？又是怎么用的呢？
		
2.  06h-f5
	
	根据通信协议的不同， 04 从节点停复电事件报文 05 拒绝节点信息上报
	其他的是，将非本台区的电能表信息上报给集中器。报文内容是扩展的645协议。

	上报的376.2协议中，有台区标志，0表示从节点台区归属无异常 1表示有异常。
	
	问题？
	05hf6和06hf5的联系在哪里？
	
	
	台区归属有异常的时候，会上报。
	台区识别上报的表暂时缓存在链表上，后续处理是怎么样的？？
		后续是怎么上报给主站的？
	
	这个地方是有误解，05h-f6这个是下发给路由的，路由就自动开启台区识别，是不需要集中器来做处理的，这就是说这两者之间是不需要联系的。
	
	但是，在05hf6中做的处理是什么意思？
	
3.  节点信息上报

4.  台区识别

	台区识别 数据域长度是7？ 包含的是那些内容？--电能表地址和所属台区地址？


1. 首先要做上行接口。
	
	set和get
	由于居民用电到任务调度并没有启动台区识别的接口，所以采用居民用电将设置的参数存入到数据中心，数据中心给出通知，任务调度来启动台区识别。
	
	get是通过AFN10,F4来读台区识别使能标志。
		这个在模组化的代码中是如何实现的？
		首先来读AFN10的时候，肯定是在任务调度这边来读的，这个地方是不是就少了一个接口？

	f209_22 这个就是存到数据中心再读数据中心就可以。

2.  任务调度收到启动台区识别的通知，下发05h-f6启动台区识别。
		需要收到确认报文吗？

3.  台区识别的流程还是需要在理呀

	根据06h-f5上报的报文，找到645报文，就可以找到数据电能表的地址和所属台区地址，存入到数据中心，问题是怎么存进去呢？按照什么样的格式？
	
	存储前查重？这个要怎么做？
	存储前怎么从数据中心取得最大的信息点号？ --- 通过上一条记录吗？ 还要求要对信息点号处理。




2020年10月28日10:59:21   今天把台区识别移植完

大体分一下流程
1.首先是上行接口，启动台体识别，添加台体识别的任务
2.

在一点之前，要大体理出流程：
先一个个的解决，先做台体识别。

1. f209-11 台区识别启停标记
	一定是从这里开始，解析主站下发的报文，并把它存到数据中心，数据中心给出通知，然后会添加一个台区识别的流程？

现在基本的流程就是，首先下发一个05f6启动台区识别
然后就是等着上报。

挺麻烦的主要是流程不清晰。

首先还是要看明白主分支的处理。


主分支处理细节分析与思考：
1.f209-11的结果可定就是0或者1，这样对应到任务调度APP的时候，肯定是要先删除原来的任务，然后在下发允许或者禁止的命令，下发不同命令对应的处理也就不同
当下发的是允许的时候，做了很多清空的操作。这些文件链表hash表，都是在什么地方用到了

2.主分支的流程应该是发下了允许台体识别的命令，就等着06f5上报了。那么上面的这些表什么的也就是应该在这个地方上用了，不然就是有自己理解的不到的地方

3.会对06f5上来的645报文进行解析，当台区归属异常的时候，会组一个跨台区结果包含通信地址，主节点地址和变更时间，把它存放在数据中心。

问题1，这里只用到了缓存到链表上，并没有用到其他的文件hash什么的，要继续找一下
-----get_area_ident_from_link_and_handle，从缓存台区识别结果的链表上取表信息存文件并按需上报，在这里面用到了其他的方式。

问题2，这个流程不好融入到现在的任务中，需要考虑下如何做？

4.现在只考虑到把这个结果存入到数据中心，有两个问题
	1.流程，怎么融入到现在的形式？
		还是要添加任务？任务参数该如何配置呢？----- 任务参数的配置应该是可以参考识别流程那些流程。
		主分支启动台区识别的流程：
		_wait_direct_local_module
		
		如果是05f6是和正常的op是一样的。
		
		如果状态机是收到数据就会切换到op2.我怎么知道收到的数据和op1是对应的呢？
		
		状态1： 发送允许台区识别的命令。 切换到状态2.
		状态2： 在op1中等待，等待收到06f5后切op2来处理数据。
		
		首先能想到的也就是这些东西，边做边思考把。
		
		
	
	2.如何查重去最大信息点号，来存入到数据中心？


5. 实现细节
f209-0b 这个要实现的是，把它当成参数写入到数据中心。 --- 这部分并么有问题。

_area_ident
怎么才能确定这个流程结束呢？
现在主分支的处理是，下发允许台区识别以后，就会等待06f5上报，有上报就把他挂在链表上。
这样在op中处理，就麻烦了，不知道什么时候结束这个op。
	----- 这个地方确实是我没有注意的，原来程序中是有关于 路由主动上报应用处理的。response_afn6_f5
	（这个地方是收到376.2报文后，会首先判断一下是不是路由主动上报的，如果是处理并返回，如果不是的话会继续往下走，执行到fsm_recv_data状态机收到数据，切换状态。）

先把这个问题，放过去，往下继续走。 ---- 这个问题已经解决。

现在要解决的是，就是组一个结构并把它存放到数据中心，这个有两个问题，
1. 要查重，根据表地址查重 ---- 添加任务的时候？
2. 

----- 要借着这个机会，把数据中心的接口熟悉一下。









    cnt = dbcenter_para_get(0x60020500, 0xFFFF, pd, SIZE_1M);
    if (cnt > 0)
    {
        for (i = 0; i < cnt; i++)
        {
            if (get_be_val(pd + pos, 4) != 0x60020500) break;
            pos += 4;
            pos += 2; //2字节数据类标识
            pos += decode_variable_len(pd + pos, &tp);
            if (tp != sizeof(OOP_ACROSSAREA_RES_T)) break;
            acrossarea_ret = (OOP_ACROSSAREA_RES_T *)(pd + pos);
			pos += tp;
            if(0 == memcmp(acrossarea->commAdd, acrossarea_ret->commAdd, 6))
			{
				APP_PI(addr is here already !!!! \n ");
				return 0;
			}
        }

		dbcenter_para_set(0x60020500, ++cnt, acrossarea->commAdd, sizeof(OOP_ACROSSAREA_RES_T);
	}

现在要做的对台区识别处理
	要组一个跨台区的结果，然后把它存到数据中心就可以了。
	
**********
·	存在了一个很大的问题，就是信息点号超过2000后，帧序号该如何做？
最大存储信息点号为2000，如超过2000则继续从1开始记录。
	按现在的程序，通过信息点号ffff，读出所有的个数，如果超过2000，变为1，就会覆盖原来的1，在判断最大的还是2000？
		--- 现在的处理是认为上报的永远不超过2000
	所有的到2000，变为1的都存在这样的问题。


现在已经把把跨台区结果，存入的数据中心，数据中心要给居民用电上报60020500数据变更事件，然后居民用电生成事件
	----- 这部分可以先看一下林哥，现在是如何在居民用电处理事件的，然后再根据主分支的处理生成事件。
	

在上午下班之前把林哥关于居民用电生成事件的那部分给看一下，分析一下改动和实现：

1.存入数据中心，60020500用的是参数的接口存入的，但是我看到即使是参数的接口里面用的也是写普通数据来实现的，那么参数和数据可以通过什么来区分吗？
	---- 可以通过数据类标识，来区分存入是参数还是普通数据。

首先要看一下，当数据中心被写入数据时，怎么给出数据变更事件的呢？

还是需要把林哥写得这些代码看一下，看林哥是怎么用的？

事件的产生和上报有什么联系，什么事件是需要上报的？

以3105电能表时钟超差事件为例分析：

应该是采集数据4000抄到了电表的时间存在数据中心，数据中心给出数据变更事件。
do_check_mt_event
数据变更事件给出的内容有信息点号，数据类标识和数据项标识。
这个地方可以看一下抄到4000的数据是任务调度是怎么存到数据中心的？
	在存数据的时候，这个信息点号就是存的电表的序号。

所以，可以通过信息点号找到这个电表的信息

会判断一下oad，oad是4000的时候，才会判断是不是电能表时钟超差。

今天把事件部分仔细看一下？

事件的分类：
---- 终端产生的事件，需要终端判断来产生事件。
---- 电表产生的事件，这类事件是通过6012召测到的。

事件部分分析：

一般都是通过generate_event和generate_mt_event，后者是判断电表的数据产生的事件，这都是终端产生的事件，是需要终端来判断产生事件。上面两者的区别是addr前者用的集中器的地址，后者用的是电表的地址。
	这两个函数是包含了上报的那一套的。

生成事件的套路，都是差不多的。
1.都要读一些参数，来判断一下事件是否发生。
2.组织事件数据，产生事件。





















