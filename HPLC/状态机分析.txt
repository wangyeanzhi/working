

1.  fsm_init 状态机初始化函数
	
	在pre_run函数中，来初始化状态机
	里面包含 fsm_attach 和 fsm_setstate 函数。
	
	在fsm_attach函数中起了一个定时器和协程
	在fsm_setstate函数中设置状态机的初始状态
	
	
2.  这里面有两个比较重要的数据结构

	fsm_t *fsm 和 fsm_state_t *states; 这个就是 整个状态机的数据结构和状态机中某个状态的数据结构
	fsm_t中包含了fsm_state_t
	这里面有两个wait，一个是fsm_t中包含了wait，再就是每个状态中包含一个wait，如果给状态机的wait赋值，就不是用每个状态中的wait
	
3.  调度

	这个调度就分了三种情况：
	
	首先，在fsm_setstate函数中通过赋值的初始状态，找到这个初始状态所处的哪一个状态。 .cmd = fsm_msg_state_change, .arg = (void *)op,这样触发fsm_attach中的那个协程。最终执行 fsm_do_setstate(fsm, msg.arg)，在这里把有初始状态找出来的状态赋值给状态机。并且fsm->init = 1，表明这个是状态机第一次执行。然后 fsm_schedule(fsm, NULL)。如果是第一次执行，会执行op1.
	
	如果，得到的结果大于0，则启动在fsm_attach中添加的那个定时器，时间是wait。
	
	在等回复的时候，出现了两种情况，一是定时器时间到，二是收到数据。
	
	若定时器的时间到了，还没有收到数据。触发 fsm_schedule(fsm, NULL)，由于fsm->init = 0，所以会执行op2.一般在op2中，都会判断一下，传进来的是不是NULL，一般传进来是NULL，返回STATE_CTR_RETRY，这个是负数，所以ret小于0.（注意这个地方，op2返回的都是小于0的，只有op1返回正常的情况下是大于等于0的）
	其实只有分析这个函数，才能真正的明白pre_run中状态机部分的处理。
	
	分析op2中的几种情况：
	STATE_CTR_NEXT： next一般是op2执行完了，切一下一个状态，会把下一个状态赋给state。
	STATE_CTR_RETRY： 一般是时间到了，还么有收到数据，就会重试。会把当前的状态赋值给state，并会累加重试次数，当大于最大的重试次数的时候，将失败的状态赋值给state。
	STATE_CTR_FAIL： 将失败的状态赋值给state。
	注意这三个赋值完，都会再次执行fsm_setstate，再次重新执行一个状态。
	
	STATE_CTR_WAIT： 直接return ret; 什么都不做等着。
	
	还有一种情况是，时间没有到，收到了数据。fsm_recv_data触发协程，执行 fsm_schedule(fsm, msg.arg)，正常的执行op2
	
	
	
4.  总结
	
	主要是有三种情况可以触发状态机的调度：
	
	（1）设置状态机的状态。在第一次初始化状态机的时候，会触发调度，这个主要是完成op1的发送。在op2中，一般返回的也是首先更改状态然后在调用设置状态的函数，从而触发这个，完成op1的发送。
	若op1发送正常，返回的ret>=0，在这里会启动一个定时器，时间是wait这个wait的时间由fsm中的wait和op中的wait决定。
	
	（2）定时时间到，但是没有收到数据。触发状态机的调度，这个地方会进入op2中，但是数据是NULL，可以根据这个NULL来做一定的处理，像在抄表的时候就是直接返回重试，也就是一定的时间内收不到抄表的数据，就会重新发送一遍。
	
	（3）收到了数据，进入op2，处理收到的数据。
	
5.  其实想想，状态机的调度还是挺简单的。

这里面,有一个地方么有转过来,就是op1 return后的后续,单纯的去写一个return, 看着就有点懵, 但是下发376.2报文也是用的return. 
这个问题还是切换的问题, 就三个情况可以触发状态机调度, 设置状态机的状态, 定时时间到, 收到数据, 和return没有关系.

关于时间等待:
如果在op1中, return wait, 那么就什么也不会做等到超时进入op2. 
















































