---
title: 台区识别
tags: vs
notebook: hplc
---

只要是加上了这个开头，然后使用ever publish就可以推到印象笔记

**现在又有另一种假装努力的方式来逃避，学一些不懂脑子的东西，来逃避现在棘手的问题**

2020-11-3 09:40:14 该干点正事了。

其实，这段时间总在纠结现在代码实现上，有一点其实该明确，就是现有代码并不是标准答案，只是一种实现方式，可能当时这么处理，只是为了过台体,就这么处理了，并不需要刨根问底，就像前几天说电能表超差事件处理有问题。</br>

#### 还是要先看事件的产生
##### 3105时钟超差
**注意：**其实，每个事件应该是有两部分的，事件的产生和事件的读取，为了简单现在只做事件的产生</br>
3105时钟超差，有一个属性6是配置参数，通过这个参数来判断事件的产生。

分析3105产生的流程：
**要明确，是怎么引起这个流程？ 是任务调度抄表，抄到数据然后存入到数据中心，数据中心给出数据变更通知，然后触发这个流程**

* 判断事件是否有效 方法9是有效标识
* 读出31050600的配置参数，作为后续比较
* 要把存入的时间数据从数据中心读出来
* 在数据库读出上一次的存储的时钟差值，并计算这次的时钟差值存入数据库。
* 通过时钟差值和310506的配置参数比较，产生事件

在产生事件的这个函数中，
```c
int generate_mt_event(u8 addr[6], u16 oi, u32 start_sec, u32 end_sec,
                      u8 srclen, void *data, int dlen)
```
**只把这个事件产生放到了本地数据库**</br>
这个函数的参数，包含addr就是事件发生源，start_sec是事件开始时间，end_sec是事件结束时间，data中包含了电能表时钟和终端当前时钟</br>
事件记录序号是读出数据库上一条的序号+1</br>
并没有管电能表时钟超差记录单元中的关联对象属性的数据，我认为应该是根据台体测试做的，没有用到这个关联属性就没有做。</br>

以上，分析的都是流程，和真正的程序实现还是有很大的区别。</br>
细节分析：</br>




##### 3118终端编程记录


2020-11-3 13:54:36
想都是问题，做才是答案。

























