
状态机看了好多遍了,可是没有一遍能静下心了,都是一知半解的就结束了.  

这个状态机总共只有不到300行的代码,可是到现在也没有真的看明白.

状态机触发调度有三种方式, 这个我已经明确了, 但是一知半解最害人, 觉得懂了, 其实这个根本就么有明白原理.

状态机的代码虽然短,但是却把程序中的这些框架都用上了.

首先是在pre_run中, 初始化一个状态机, 里面包含了两个函数: fsm_attach 和 fsm_setstate
fsm_attach是状态机的注册,在里面起了一个协程和添加了一个定时器.(这个定时器是单次触发的)
fsm_setstate在里面组了一个消息,正好是发给协程来处理. 这个消息是fsm_msg_state_change设置状态.
(上一次,认知只停留在这是一个设置状态, 但是要注意的是, 必须执行的的是op1, 并且op1的返回值必须是大于0的, 因为必须大于0才会在处理的时候, 开启在fsm_attach中添加的那个定时器)

定时时间到或者是收到数据, 执行的是op2, 并且op2的返回值,要小于0. 这就是为什么切换的那几个状态要定义为负值的原因, 在最后都会在执行fsm_setstate, 设置一下状态, 再次执行op1.

但是有一个特例, STATE_CTR_WAIT是直接返回, 并没有执行fsm_setstate, 它的后续如何? 
STATE_CTR_WAIT是直接返回,也就是没有任何后续操作,这个协程就没有动作了, 而且现在只有一种方式, 再次触发协程, 就是收到数据.(因为并没有执行设置状态, 并且启动的定时器是单次触发的)

这是一个协程, 这个协程是需要触发的, 为什么状态机是连续的操作, 因为实在不断的触发, 如果返回了STATE_CTR_WAIT, 就是停止连续触发. 并且只有一种方法就是收到数据才能再次触发协程.



























