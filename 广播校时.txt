
1.  4204--02/03的上行接口，set和get来设置广播校时的参数。


	广播校时流程比较简单，就是获取数据中心的广播校时的参数，这个应该是4204-02set写入到数据中心，数据中心给出通知，采集任务调度来读取参数，判断是否广播校时启动条件，分别对698/07/97表进行广播校时。


	还是把广播校时做出一个任务。

	还是要仔细的阅读
	
	广播校时有四种情况：
	4204—02，4000—127，还有两种是和透明转发有关，透明转发的376.2协议报文中，AFN=05H，FN=F3，这是376.2的广播校时，但是，在这里只做前两个就可以。
	
	首先是要分析，两者的不同。
	4000-127  add_brd_task(NULL, SPECIAL_PRO, time, 6) 这个是立即启动
	4204-02   add_brd_task(time_broadpara.time, 0, NULL, 0) 这个是周期启动

	这个首先也是要把4204和4000的上行接口做出来，
	然后，根据接口来添加任务。

	广播校时到底是怎么样的流程？
	过程应该是这样，首先要组织一个645或者698的报文，然后用376.2的报文把这个698或者645的报文包起来。

2.  先做广播校时，今天做完。
	要做4204和4000的上行接口。
		现在的代码中，上行接口的那部分代码已经是有的，只是没有做后续的处理。4204这个上行接口的处理，应该是吧参数存入到数据中心，数据中心给出通知，然后任务调度来读取这个参数，添加任务。
		
		问题1：现在已经是写入到了数据中心，如何任务调度来读取这个参数呢？
			数据中心给出的是什么通知？任务调度又是怎么过来读的呢？
				--- 流程是这样的，数据中心的数据发生变化后，就会给出数据变化的通知到任务调度，任务调度会判断是不是要抄读的oad，然后去数据中心读这个参数。读出这个参数写入任务调度本地的数据库，然后数据库给出参数变动通知，从而加载任务。
				
				dbsync_setup -- on_dbcenter_update -- db_sync_one_infoseq -- set_para 
				这个过程是：上行接口写4204的参数到数据中心，数据中心给出通知，通过判断oad来判断是不是要去数据中心读这个参数，如果读的话，会在数据中心读到这个参数，并把这个参数写到任务调度的本地数据库。
				
				然后，会检测到本地数据库变动，读出参数来加载广播校时的任务。
				
		问题2： 上行接口4204是把什么数据存到了数据中心？
			OOP_SYNCTIME_T time_broadpara;
			
		问题3： 现在已经做好上行到加载任务，但是问题是有两种4000—127和4204-02。
		
		注：因为4000-127,没有接口，那么就先不做这个，先把这个地方记录下来。（在深化应用实现文档中也只是有周期广播校时）
		
		如果只做周期广播校时的话，就简单了一些
		
	然后就是做任务的那部分。
		
		但是任务这部分做的时候，应该是要把立即启动的那种情况给做进去？

3.  林哥已经完成了，采集任务那部分功能。 --- 并没有完成。

	这一周要做完全部的任务，并且已经过去了一天，在拿出一天的余量，总共还有5天，正好是一天一个。难度很大，挑战一下。


4.  其实对任务那部分也不是很熟，也并不知道都是干啥的，正好根据这个机会来整理。


	还是需要把套路给弄明白。
	
5.  其实要做的就是，组一个任务，周期启动的任务，把任务号，方案号，方案类型，开始时间结束时间，周期这些参数都组成一个tcb，并且把它挂到任务上，再就是要注意细节，多想想会不会有其他的情况。


6.  首先可以只做简化的周期校时。

	all_state.brd.loop = 2;
	做最简单的周期校时，所有的函数都简化，不考虑兼容。


	1. 不考虑立即执行的情况，
		那么，怎么划分状态呢？
		首先，看一下，抄表的时候是怎么组帧的？














	
	广播校时的流程：
	首先判读有没有698表，如果没有判断有没有645表，如果两种表都没有则结束。


要有一个_get_modeinfo的操作，这里面会把路由的信息都保存下来，在现在的代码中有这样的操作吗？
	现有的程序，也有同样的操作，在识别流程中，03hf10，那延时的信息放在了cce->rinfo.cco_mode中。

关于延时的调整，698帧的时候，只有4000的时候才需要调整吗？
	应该不是这么理解的？
		组织的698的报文就是40007f00。 这就是发给电表的广播报文。
		
	05h-f3这个是有确认帧的，里面有一个等待的时间，这个是有用的。
	问题：
		发送完一个广播帧是如何通过等待的时候，还切换状态的？
		
	可以看下这个流程，是按照什么来分的？按照下发376.2报文？

任务这个地方分为了两大部分：
1.  要组织任务 要组一个tcb。这个就是add_brd。。。这个函数中的内容

首先要判断这个任务在链表上有没有，有的话就把这个任务从链表上删除。
tcb = task_get(&m->tl, CCE_DIRECTRD_TASK);
从链表上删除用的什么函数？
task_del(&m->tl, name);
现在已经把tcb组织好，然后就是进行pre_run中的状态机。

现在这个地方，
	这个地方有理解不到位的地方，是要把报文下发下去，才会知道这条报文会延时多长时间。也就是用到了这个帧。
	
	所以可以是先把帧都组织好。 要做的就是组帧
		这就是要看，现有的程序是怎么组帧的？
	
问题在于怎么组帧，用什么方法，
还有就是，在什么地方组帧？


判断698表的个数，组698帧，计算延时，到发送698广播
解帧+延时，发送698广播，到645组帧
判断645的个数，组645帧，计算延时，到发送645广播
解帧+延时，发送645广播

再就是组帧，为简单期间，直接移植主分支的代码。
	
	
	状态机：
	1. 暂停路由
	2. 判断有没有698帧，有的话
	2. 判断延时相关，计算出时间。
	3. 判断与没有698表，解帧加延时在组帧发送。
	4. 判断与没有645表，解帧加延时在组帧发送。
	5. 结束。
	
	
	


能不能在pre_run之前，就把698的帧和645的帧组好。
暂停路由  ---- 还需不要暂停路由
根据是否延时相关，来查询延时的时间，03H-f9
判断是否有698表，解帧，加上延时时间，发送。---- 切换的依据是根据，上行的确认报文吗？
判断是否有645表，解帧，加上延时时间，发送。---- 切换的依据是根据，上行的确认报文吗？
结束。

问题： 周期加载的任务当程序重启时，是要重新加载的。
	这个是可以参照抄表任务的。
	放的位置应该不是main函数，而是和识别流程放在一起，这个任务是并没有保存的，怎么重新加载是个问题。


二  单地址广播校时


4


大体也就是这些流程，光写这些东西，不写代码是没有用的。










2020年10月22日  定个小目标，上午把广播校时的程序做出来





关于重试次数：
下发376.2协议重试，重试有什么规律吗？
现在倒是可以根据主分支的方法去处理？


状态机状态：
1. 首先是暂停路由，这个应该会尝试3次，如果超过三次就结束
2. 在状态1中，判断698的个数，同时可以在状态1中切换状态吗？在程序中，找到了这样用的 return FSM_CHANGE_TO(fsm, FSM_STATE_IDLE);
	首先在状态1中，判断698的个数，如果698的个数<=0，则切换到处理645的状态。如果是存在698的表，则组698的帧，下发下去得到延时时间。先组帧，然后判断是否是延时相关，这个需要把组好的698的帧和延时的数据都保存下来，如果延时的时间为0.则不需要解帧，直接广播保存的698的帧。

	首先要是要把698的帧和延时的时间保存下来，这个地方可以参照抄表的地方。

    struct cce_dev *cce = app_to_cce(app);

    pb_reset(cce->parent.pb);

	在状态2中，一般是收到数据或者等待超时会进入状态2.
	如果是超时进入状态2的，调整时间是0


3.  到这一步，已经有了698帧和延时时间
	
	首先解帧用的是什么？要用协议的东西吗，协议部分又是怎么用的呢？如果
	
	
	


要么瘦，要么死。
发下过很多这样的宏愿，却一次也没实践成功，这次呢，要么瘦要么死。

一个原则：能移则移，以快为最

不要再想有没有更合适的方案，先把它弄完才是现在最主要的。

凡是不要想当然，有些函数看着是应该可以实现某些东西，可是真的去做的时候却存在偏差，错误。



到第三步了，解帧加上延时时间，然后在发698的广播，
这个地方645和698完全是一直的，所以解决了这个地方，也就解决了全部的

	首先采用协议解帧，确定能把协议类型传过来。



    const struct protocol *prot;   
	prot = proto_get(dl698);
    assert(prot);



2020年10月26日08:27:45

在遇到困难，懊悔颓废都是没有任何作用的，要想办法去解决。浪了这么久，不该再浪了。
要做一点测试一点，别弄完，和自己的理解差太多

首先要把组好的698帧和延时的时间给传进来。

问题1：现在是把组好的帧放在了app->data中，现在好像是没有个数，怎么把它取出来用呢？
	先去看看现在有没有用的？如果不行的话，先把第一个字节作为帧的个数。
	能不能换个思路，不是把帧放在data中，而是把pafn03_f9放进去，这里是有长度的。
	
问题2：并不能计算698的个数和判断延时。 
	先屏蔽掉这个问题，往下推进。

问题3： 又卡在了解帧这个地方。
	还是需要通过协议来解帧？
	如果不解，直接在组呢？

问题4 需要等待一定的时间？
	参考抄表的地方。

app_to_cce(app)->parent.tl.now
time_after_eq(now, mt->expires)


68 99 99 99 99 99 99 68 
08 
06 
6b 8b 47 59 43 53 
39 59 14 26 10 20

a0 16

--------------- 广播校时告一段落 还有一个问题：  就是这是一个周期任务，还没有上报自启部分，这个在单地址校时弄完以后要一起坐上。




----------------------- 2020年10月26日15:43:45 单地址校时
这个比广播校时要更麻烦 但是怕也么有用，加油。


草，一走神又没了好多的时间。。。
集中精神呀 哥






1. 420403参数写进去，启动单地址校时任务  把参数都读出来
		最简单，先把这个部分做出来。这一个最简单，解决。

2. 首先会配一个抄时间的任务，抄回来的数据要和集中器时间作比较，存起来判断？
	这部分是最麻烦的，要清一下主分支的处理。

3. 要把校时的信息存入到数据中心，

4. 数据中心给出通知，到任务调度生成事件。

----- 做的时候，也是分成上述的四步，

4204-03 有一个

is_beyond_err_limit
save_meter_time_err
exp_mt_time_err
write_mtr_data
save_mt_result_to_db


存储电表单地址校时事件数据
save_single_brd_event
sh_single_brd_event
save_mt_result_to_db
travel_task_period
sys_sec_action
check_mt_exp

save_single_brd_to_list
insert_mt_result_to_list
response_afn13_f1 监控从节点

这是产生事件的部分，具体的流程还是不太了解，需要问一下

set_single_brd_wait_flag
send_single_brd_frame
run_single_brd_flow



其实，如果是大体的了解一些功能如何实现是简单，难是细节的把握。
1.  4204-03首先要配置单地址广播校时，会有启动的阈值和启动的时间。
2.  要抄读40000200，要将抄回来的时间和

分析APP深化应用实现：
1.首先是要根据采集任务抄读电能表的时候，判断40000200标志，来判断抄回来的数据和集中器的数据做差，计算出误差放在任务调度本地数据库中？ ---- 放在新增的那个数据库中？

2.任务调度要在数据中心获取42040300参数，来根据误差来判断是否产生校时。
	这个应该也是，把420403写入到数据中心后，发出通知，添加单地址校时任务，会判断启动条件和误差阈值。

3.任务调度把校时的信息，存入到数据中心，数据中心给通知到居民用电。

4.居民用电产生电能表对时事件

5.居民用电可以删除校时信息



一步步的来，先做第二步，就是任务流程部分。


细节：
1.通过13H-f1来下发的单地址广播的校时。下发的报文是什么，是03广播吗 为什么
2.645表不支持单地址校时。
3.主站配置抄读40000200，程序处理抄读回来的时间和集中器时间错差，计算出该电表始终差，存起来
4.通过42040300启动单地址广播校时，来读取这个差值与阈值做比较，大于则对改电表进行单地址校时，并把校时内容存到数据中心。

这么看，又把上面的内容分成了两部分，一是抄回来的数据，应该是在抄表的地方，要做处理，如果是40000200的话要做差，并保存到本地数据库。----- 先做这一部分。





在 response_afn13_f1 还有 save_single_brd_to_list 关于单地址校时的处理。
is_beyond_err_limit 这个函数是将存起来的误差和阈值作比较，在单地址的流程中的。

save_meter_time_err 这个函数中，做了差  exp_mt_time_err  check_mt_exp  write_mtr_data

这个就是应该 在抄表抄回数据的地方，把每个电表抄回的40000200数据和集中器时间做差，并保存在本地数据库。 
	- 问题在于本地数据库的数据表是怎么样的，我现在又是怎么用的？
	

研究下林哥建立的两个表，看看怎么用？  要实现的就是做差，然后放在本地数据库。
那就是用参数表

int ldbi_usrdt_get(u64 mid, u32 pro, u32 did, void *data, u32 maxlen);
int ldbi_usrdt_set(u64 mid, u32 pro, u32 did, void *data, u32 len);
就是用上面这两条

开始干！
要查重往里面放，新旧不同才放进去！
这个地方可以参考下任务方案那个地方。

1c 
07 e4 0a 1a 13 3b 2c
2020 10 26 

现在已经是已经放在了本地的数据库，

现在要做的就是把流程方面的东西做完。



    if (PORT_PLC == p->mtpara.port)


现在要做的有两步
1.组织广播报文，下发单地址广播校时命令
	现在看来并不是向自己想的那样，流程简单，而是和广播流程高度相似，还有就是事件那部分要仔细的捋一下代码，别想当然，不能图快。



2.将校时信息存入到数据中心。

在 save_single_brd_event 这个函数有对校时前时钟的处理
time_delt_calculate(cur_bintm, -meter_time_err, before_brd_meter_bintm);  /*校时前时钟*/


sh_single_brd_event -- save_mt_result_to_db -- travel_task_period
这个是从链表上取下来处理
是什么时候挂到链表上的？


exp_mt_time_err

这个发单地址的校时可以参考抄表对表的控制。不是并发的情况。

现在要做的就是，首先要把本地数据库中数据读出来，判断是否大于阈值，若大于要发送单地址广播校时的命令。
这里面就有一个问题，怎么来确定有哪些要校时，怎么确定这个表数量的？

1.通过表序号来找表地址，判断一个最大的表序号。可以用这个


单地址这块，还有很多的东西没有做，今天能做完这块，也不容易了。
1.流程有点卡住，这部分需要问一下华哥
2.还需要做事件部分

这个地方就是有个帧序号理解不是很好。

还有华哥改动的地方可以先不管？ ---- 这个单地址校时放在最后，先完成其他的内容。





