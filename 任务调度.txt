
2020年10月27日 到今天我也没有说对任务调度这一块滚瓜烂熟。

趁这个机会，再次把调度和状态机这部分捋一下。

寻找共同的m
cce就可以理解成路由，里面包含一个路由基础和路由信息，还有一个状态机。
会把所有的载波任务都挂在m的一个链表上。

task_schedule 任务调度。

程序的执行有一个特别，不能理解成线性的，会通过函数指针不断的把程序指出去，在别的地方处理，程序则继续往下走，往下循环。

任务调度的理解：

首先要明确这个函数是每秒执行一次。就是不断的执行调度函数。

1.首先会遍历任务链表找到一个最应该执行的任务（通过一定的算法）
2.判断一下当前的任务和链表找出的任务是否相同
	若不同：分为当上电，当前任务为NULL；二是，确实出现更应该执行任务
		若不同且当前任务不是NULL，就要把着这个任务暂停。
		若是NULL，就执行pre_run（指到别的地方执行，调度函数继续往下执行）
			并把任务状态置为running。
3.然后向下执行到run函数（这个地方我一直以为是，pre_run执行完再执行run，其实不是，pre_run被指到一边，继续执行run，这个run中会判断程序执行状态机是不是执行到FSM_STATE_IDLE这个状态，否则会结果置为TASK_RET_DOING。
4.下次在进入到这个调度函数是，就会判断结果是不是TASK_RET_DOING，如果是的话直接返回，如果不是则会判断执行post——run，下面的内容就不先分析了。
	这里要注意的是，程序会根据状态是不是FSM_STATE_IDLE，来判断pre_run是不是执行完了。

状态机：

主要是分析下返回不同的内容对程序的影响。

状态机分析：
1.fsm_init这个是pre_run中的函数，是对状态机进行初始化，里面包含两个函数
	fsm_attach：在这里添加了一个定时器和一个协程。
		协程中是对状态机的调度。
	fsm_setstate：在这里设置状态机的一个初始状态。
2.设置初始状态后，状态机中的一个信息会被改成状态机状态改变，从而触发协程。
	fsm->init = 1
	fsm_schedule(fsm, NULL)
	由于fsm->init为1，所以会执行op1，并把fsm->init清零。
		执行op1有几个结果：
		STATE_CTR_NEXT，STATE_CTR_RETRY，STATE_CTR_FAIL这些都是小于0的。
	#define FSM_CHANGE_TO(fsm, state) ((fsm)->next = (state), STATE_CTR_CHAGE)	
		先分析这些结果小于0的情况，这些都是和切换状态有关，会把改执行的状态在重新设置一下，再次调度，执行op1.
		
		如果不小于0，则会启动一个定时器，当定时时间到，会再次调度函数，细心变为fsm_msg_alarm，执行op2
		
3.有三种引起状态机调度的情况
	1.设置状态。不论是一开始设置初始状态，还是切换状态后，都会引起状态机调度，并且执行op1.而op1的结果往往是cce_apdu_output这个下发一个376.2报文，所以结果往往是大于0.
	
	2.结果大于0，就会启动一个定时器，定时的时间，就是设置的等待时间，当这个等待时间结束后，还没有收到数据，则也会引起状态机调度，这个地方执行的是op2，其中数据是NULL。一般在op2中都会判断数据是否是NULL，若是NULL往往会重试。
	
	3.op1下发报文后，启动了定时器，在定时器没有结束以前，收到了数据，也会调度函数，执行op2.
		结果还是有两种：
		>=0：回启动定时器，重复2。
		<0: 切换状态，重复1

































































































